//See LICENSE for license details.

package firesim.fasedtests

import java.io.File

import scala.io.Source
import org.scalatest.Suites

import firesim.TestSuiteUtil._
import firesim.midasexamples.BaseConfigs

/** Different runtime-configuration modes extend this trait. See below. */
sealed trait RuntimeConfig {
  def behaviorString: String
}

/** Use the .conf generated by GG by default. */
case object DefaultRuntimeConfig extends RuntimeConfig {
  val behaviorString = "with default runtime conf"
}

/** Provide no conf file. PlusArgs must be called out in the test class. */
case object EmptyRuntimeConfig extends RuntimeConfig {
  val behaviorString = "with no base runtime conf"
}

/** Specific an alternate path to a conf file. */
case class CustomRuntimeConfig(pathRelativeToSim: String) extends RuntimeConfig {
  val behaviorString = s"with runtime conf ${pathRelativeToSim}"
}

trait MemoryStatsCSVConstants {
  val readOutstandingHistogramPrefix  = "readOutstandingHistogram"
  val writeOutstandingHistogramPrefix = "writeOutstandingHistogram"
  val targetCycle                     = "targetCycle"
  def memoryStatsFilename(idx: Int): String = s"memory_stats${idx}.csv"
}

/** A specialization of TestSuiteCommon for FASED-specific testing. Mostly handles differences in the makefrag vs
  * midasexamples..
  *
  * @param targetName
  *   DESIGN: target top-level module class
  * @param targetConfigs
  *   TARGET_CONFIG: config string to parameterize the target
  * @param platformConfigs
  *   PLATFORM_CONFIG: config string to configure GG
  * @param baseRuntimeConfig
  *   Default runtime conf handling for runtest
  * @param additionalPlusArgs
  *   Non-standard plusargs to add to runTest invocations by default
  */
abstract class FASEDTest(
  override val targetName:    String,
  override val targetConfigs: String,
  platformConfigs:            String        = "",
  baseRuntimeConfig:          RuntimeConfig = DefaultRuntimeConfig,
  additionalPlusArgs:         Seq[String]   = Seq(),
  profileInterval:            Int           = 10000,
) extends firesim.TestSuiteCommon("fasedtests")
    with MemoryStatsCSVConstants {

  override def basePlatformConfig = BaseConfigs.F1

  def invokeMlSimulator(backend: String, debug: Boolean, args: Seq[String]) = {
    make((s"run-${backend}%s".format(if (debug) "-debug" else "") +: args): _*)
  }

  def runTest(
    backend:            String,
    debug:              Boolean,
    logFile:            Option[File]   = None,
    baseRuntimeConfig:  RuntimeConfig  = baseRuntimeConfig,
    additionalPlusArgs: Seq[String]    = additionalPlusArgs,
    additionalMakeArgs: Seq[String]    = Seq(),
    behaviorSpec:       Option[String] = None,
  ) = {
    val runtimeConfArg: Option[String] = baseRuntimeConfig match {
      case DefaultRuntimeConfig      => None
      case EmptyRuntimeConfig        => Some(s"COMMON_SIM_ARGS=")
      case CustomRuntimeConfig(path) => Some(s"COMMON_SIM_ARGS=${Source.fromFile(path).getLines.mkString(" ")}")
    }
    val plusArgs                       = Seq(s"""EXTRA_SIM_ARGS=+profile-interval=${profileInterval} ${additionalPlusArgs.mkString(" ")}""")
    val logArg                         = logFile.map { logName => s"LOGFILE=${logName}" }

    val makeArgs =
      runtimeConfArg ++:
        plusArgs ++:
        logArg ++:
        additionalMakeArgs

    it should behaviorSpec.getOrElse(s"run") in {
      assert(invokeMlSimulator(backend, debug, makeArgs) == 0)
    }
  }

  def checkMemoryStats(modelIndex: Int): Unit = {
    val statsFilename = memoryStatsFilename(modelIndex)
    behavior.of(statsFilename)

    def statsMap = {
      val memoryStatsFile = new File(genDir, statsFilename)
      parseCSV(memoryStatsFile).mapValues(_.map(_.toLong))
    }

    def targetCycles = statsMap(targetCycle)

    def checkOccupancyHistograms(binPrefix: String): Unit = {
      val readColumns = statsMap.filterKeys(_.startsWith(binPrefix))
      val sumOfBins   = readColumns.values.transpose
        .map(_.sum)

      for (((cycle, sum), i) <- targetCycles.zip(sumOfBins).zipWithIndex) {
        assert(
          cycle == sum,
          s"Row ${i}, target cycle ${cycle}: sum of ${binPrefix} bins did not equal elapsed target cycles.",
        )
      }
    }

    it should s"have its read occupancy histogram columns sum to the target cycles elapsed" in {
      checkOccupancyHistograms(readOutstandingHistogramPrefix)
    }
    it should s"have its write occupancy histogram columns sum to the target cycles elapsed" in {
      checkOccupancyHistograms(writeOutstandingHistogramPrefix)
    }
  }

  override def defineTests(backend: String, debug: Boolean): Unit = {
    runTest(backend, debug)
    checkMemoryStats(0)
  }
}

class AXI4FuzzerLBPTest extends FASEDTest("AXI4Fuzzer", "DefaultConfig")

// Sanity checks that target output is the same when using the default runtime
// configuration and the hardwired values.
class CheckHardwiredValuesTest extends FASEDTest("AXI4Fuzzer", "NT10e3_AddrBits16_DefaultConfig") {
  override def defineTests(backend: String, debug: Boolean) {
    val logA = new File(s"$outDir/using-runtime-conf.out")
    runTest(backend, debug, logFile = Some(logA), behaviorSpec = Some("run using a runtime.conf"))

    val logB = new File(s"$outDir/using-hardwired-settings.out")
    runTest(
      backend,
      debug,
      logFile            = Some(logB),
      baseRuntimeConfig  = EmptyRuntimeConfig,
      additionalPlusArgs = Seq("+mm_useHardwareDefaultRuntimeSettings_0"),
      behaviorSpec       = Some("run using initialization values"),
    )

    "Initialization values for configuration registers" should "produce the same target behavior as using the default runtime.conf" in {
      val aLines = extractLines(logA, "AXI4FuzzMaster_0", headerLines = 0)
      val bLines = extractLines(logB, "AXI4FuzzMaster_0", headerLines = 0)
      diffLines(aLines, bLines, logA.getName, logB.getName)
    }
  }
}

class AXI4FuzzerMultiChannelTest extends FASEDTest("AXI4Fuzzer", "FuzzMask3FFF_QuadFuzzer_QuadChannel_DefaultConfig")
class AXI4FuzzerFCFSTest         extends FASEDTest("AXI4Fuzzer", "FCFSConfig")
class AXI4FuzzerFRFCFSTest       extends FASEDTest("AXI4Fuzzer", "FRFCFSConfig")
class AXI4FuzzerLLCDRAMTest      extends FASEDTest("AXI4Fuzzer", "LLCDRAMConfig") {
  //override def runTests = {
  //  // Check that the memory model uses the correct number of MSHRs
  //  val maxMSHRs = targetParams(LlcKey).get.mshrs.max
  //  val runtimeValues = Set((maxMSHRs +: Seq.fill(3)(Random.nextInt(maxMSHRs - 1) + 1)):_*).toSeq
  //  runtimeValues.foreach({ runtimeMSHRs: Int =>
  //    val plusArgs = Seq(s"+mm_llc_activeMSHRs=${runtimeMSHRs}",
  //                   s"+expect_llc_peakMSHRsUsed=${runtimeMSHRs}")
  //    val extraSimArgs = Seq(s"""EXTRA_SIM_ARGS='${plusArgs.mkString(" ")}' """)
  //    runTest("verilator", false, args = extraSimArgs, name = s"correctly execute and use at most ${runtimeMSHRs} MSHRs")
  //   })
  //}
}

// Generate a target memory system that uses the whole host memory system.
class BaselineMultichannelTest
    extends FASEDTest("AXI4Fuzzer", "AddrBits22_QuadFuzzer_DefaultConfig", "AddrBits22_SmallQuadChannelHostConfig")

// Checks that id-reallocation works for platforms with limited ID space
class NarrowIdConstraint extends FASEDTest("AXI4Fuzzer", "DefaultConfig", "ConstrainedIdHostConfig")

// Suite Collections for CI
class CIGroupA
    extends Suites(
      new AXI4FuzzerLBPTest,
      new AXI4FuzzerFRFCFSTest,
    )

class CIGroupB
    extends Suites(
      new AXI4FuzzerLLCDRAMTest,
      new NarrowIdConstraint,
    )
